<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>Gridea</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://xiaostudentqaq.github.io/favicon.ico?v=1706189538002">
<link rel="stylesheet" href="https://xiaostudentqaq.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="温故而知新">
    
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://xiaostudentqaq.github.io">
        <img src="https://xiaostudentqaq.github.io/images/avatar.png?v=1706189538002" class="site-logo">
        <h1 class="site-title">Gridea</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      温故而知新
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://xiaostudentqaq.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/prometheus-jian-kong-xi-tong/">
                  <h2 class="post-title">Prometheus监控系统</h2>
                </a>
                <div class="post-date">
                  2024-01-24
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/zi-ding-yi-springioc/">
                  <h2 class="post-title">自定义SpringIOC</h2>
                </a>
                <div class="post-date">
                  2023-11-23
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/bei-wang-lu-mo-shi-jie-shi-qi-mo-shi/">
                  <h2 class="post-title">备忘录模式、解释器模式</h2>
                </a>
                <div class="post-date">
                  2023-11-17
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/zhong-jie-zhe-mo-shi-die-dai-qi-mo-shi-fang-wen-zhe-mo-shi/">
                  <h2 class="post-title">中介者模式、迭代器模式、访问者模式</h2>
                </a>
                <div class="post-date">
                  2023-11-15
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/ze-ren-lian-mo-shi-zhuang-tai-mo-shi-guan-cha-zhe-mo-shi/">
                  <h2 class="post-title">责任链模式、状态模式、观察者模式</h2>
                </a>
                <div class="post-date">
                  2023-11-13
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/mo-ban-fang-fa-ce-lue-ming-ling-mo-shi/">
                  <h2 class="post-title">模板方法、策略、命令模式</h2>
                </a>
                <div class="post-date">
                  2023-11-09
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/zu-he-mo-shi-xiang-yuan-mo-shi/">
                  <h2 class="post-title">组合模式、享元模式</h2>
                </a>
                <div class="post-date">
                  2023-11-05
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/java-ru-he-shou-xie-shi-xian-aop/">
                  <h2 class="post-title">Java 如何手写实现 AOP？</h2>
                </a>
                <div class="post-date">
                  2023-10-30
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/jie-gou-xing-mo-shi/">
                  <h2 class="post-title">代理、适配器、装饰者、桥接、外观模式</h2>
                </a>
                <div class="post-date">
                  2023-10-26
                </div>
                <div class="post-abstract">
                  <p>结构型模式<br>
结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<p><strong>5.1 代理模式</strong></p>
<p>5.1.1 概述</p>
<p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。</p>
<p>5.1.2 结构</p>
<p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>5.1.3 静态代理</p>
<p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：<br>
<img src="https://github.com/XiaoStudentQAQ/nodePicture/blob/main/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86.png?raw=true" alt="" loading="lazy"><br>
SellTickets：抽象主题类<br>
TrainStation：火车站<br>
ProxyPoint：代售点<br>
Client：客户</p>
<p>代码如下：</p>
<pre><code>//卖票接口
public interface SellTickets {
    void sell();
}

//火车站  火车站具有卖票功能，所以需要实现SellTickets接口
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println(&quot;火车站卖票&quot;);
    }
}

//代售点
public class ProxyPoint implements SellTickets {

    private TrainStation station = new TrainStation();

    public void sell() {
        System.out.println(&quot;代理点收取一些服务费用&quot;);
        station.sell();
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        ProxyPoint pp = new ProxyPoint();
        pp.sell();
    }
}
</code></pre>
<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>
<p>5.1.4 JDK动态代理</p>
<p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p>
<p>代码如下：</p>
<pre><code>//卖票接口
public interface SellTickets {
    void sell();
}

//火车站  火车站具有卖票功能，所以需要实现SellTickets接口
public class TrainStation implements SellTickets {

    public void sell() {
        System.out.println(&quot;火车站卖票&quot;);
    }
}

//代理工厂，用来创建代理对象
public class ProxyFactory {

    private TrainStation station = new TrainStation();

    public SellTickets getProxyObject() {
        //使用Proxy获取代理对象
        /*
            newProxyInstance()方法参数说明：
                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可
                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口
                InvocationHandler h ： 代理对象的调用处理程序
         */
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    /*
                        InvocationHandler中invoke方法参数说明：
                            proxy ： 代理对象
                            method ： 对应于在代理对象上调用的接口方法的 Method 实例
                            args ： 代理对象调用接口方法时传递的实际参数
                     */
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                        System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;);
                        //执行真实对象
                        Object result = method.invoke(station, args);
                        return result;
                    }
                });
        return sellTickets;
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //获取代理对象
        ProxyFactory factory = new ProxyFactory();
        
        SellTickets proxyObject = factory.getProxyObject();
        proxyObject.sell();
    }
}
</code></pre>
<p>使用了动态代理，我们思考下面问题：</p>
<ul>
<li>
<p>ProxyFactory是代理类吗？<br>
ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：<br>
package com.sun.proxy;</p>
<pre><code>import com.itheima.proxy.dynamic.jdk.SellTickets;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.lang.reflect.UndeclaredThrowableException;

public final class $Proxy0 extends Proxy implements SellTickets {
    private static Method m1;
    private static Method m2;
    private static Method m3;
    private static Method m0;

    public $Proxy0(InvocationHandler invocationHandler) {
        super(invocationHandler);
    }

    static {
        try {
            m1 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;equals&quot;, Class.forName(&quot;java.lang.Object&quot;));
            m2 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;toString&quot;, new Class[0]);
            m3 = Class.forName(&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;).getMethod(&quot;sell&quot;, new Class[0]);
            m0 = Class.forName(&quot;java.lang.Object&quot;).getMethod(&quot;hashCode&quot;, new Class[0]);
            return;
        }
        catch (NoSuchMethodException noSuchMethodException) {
            throw new NoSuchMethodError(noSuchMethodException.getMessage());
        }
        catch (ClassNotFoundException classNotFoundException) {
            throw new NoClassDefFoundError(classNotFoundException.getMessage());
        }
    }

    public final boolean equals(Object object) {
        try {
            return (Boolean)this.h.invoke(this, m1, new Object[]{object});
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }

    public final String toString() {
        try {
            return (String)this.h.invoke(this, m2, null);
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }

    public final int hashCode() {
        try {
            return (Integer)this.h.invoke(this, m0, null);
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }

    public final void sell() {
        try {
            this.h.invoke(this, m3, null);
            return;
        }
        catch (Error | RuntimeException throwable) {
            throw throwable;
        }
        catch (Throwable throwable) {
            throw new UndeclaredThrowableException(throwable);
        }
    }
}
</code></pre>
<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
</li>
<li>
<p>动态代理的执行流程是什么样？<br>
下面是摘取的重点代码：<br>
//程序运行过程中动态生成的代理类<br>
public final class $Proxy0 extends Proxy implements SellTickets {<br>
private static Method m3;</p>
<pre><code>    public $Proxy0(InvocationHandler invocationHandler) {
        super(invocationHandler);
    }

    static {
        m3 = Class.forName(&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;).getMethod(&quot;sell&quot;, new Class[0]);
    }

    public final void sell() {
        this.h.invoke(this, m3, null);
    }
}

//Java提供的动态代理相关类
public class Proxy implements java.io.Serializable {
	protected InvocationHandler h;
	 
	protected Proxy(InvocationHandler h) {
        this.h = h;
    }
}

//代理工厂类
public class ProxyFactory {

    private TrainStation station = new TrainStation();

    public SellTickets getProxyObject() {
        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),
                station.getClass().getInterfaces(),
                new InvocationHandler() {
                    
                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {

                        System.out.println(&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;);
                        Object result = method.invoke(station, args);
                        return result;
                    }
                });
        return sellTickets;
    }
}


//测试访问类
public class Client {
    public static void main(String[] args) {
        //获取代理对象
        ProxyFactory factory = new ProxyFactory();
        SellTickets proxyObject = factory.getProxyObject();
        proxyObject.sell();
    }
}
</code></pre>
</li>
</ul>
<p>执行流程如下：</p>
<ol>
<li>在测试类中通过代理对象调用sell()方法</li>
<li>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</li>
<li>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</li>
<li>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</li>
</ol>
<p>5.1.5 CGLIB动态代理</p>
<p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;cglib&lt;/groupId&gt;
    &lt;artifactId&gt;cglib&lt;/artifactId&gt;
    &lt;version&gt;2.2.2&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<p>代码如下：</p>
<pre><code>//火车站
public class TrainStation {

    public void sell() {
        System.out.println(&quot;火车站卖票&quot;);
    }
}

//代理工厂
public class ProxyFactory implements MethodInterceptor {

    private TrainStation target = new TrainStation();

    public TrainStation getProxyObject() {
        //创建Enhancer对象，类似于JDK动态代理的Proxy类，下一步就是设置几个参数
        Enhancer enhancer =new Enhancer();
        //设置父类的字节码对象
        enhancer.setSuperclass(target.getClass());
        //设置回调函数
        enhancer.setCallback(this);
        //创建代理对象
        TrainStation obj = (TrainStation) enhancer.create();
        return obj;
    }

    /*
        intercept方法参数说明：
            o ： 代理对象
            method ： 真实对象中的方法的Method实例
            args ： 实际参数
            methodProxy ：代理对象中的方法的method实例
     */
    public TrainStation intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {
        System.out.println(&quot;代理点收取一些服务费用(CGLIB动态代理方式)&quot;);
        TrainStation result = (TrainStation) methodProxy.invokeSuper(o, args);
        return result;
    }
}

//测试类
public class Client {
    public static void main(String[] args) {
        //创建代理工厂对象
        ProxyFactory factory = new ProxyFactory();
        //获取代理对象
        TrainStation proxyObject = factory.getProxyObject();

        proxyObject.sell();
    }
}
</code></pre>
<p>5.1.6 三种代理的对比</p>

                </div>
              </div>
              
            </article>
          
            <article class="post-item">
              <div class="left">
                <a href="https://xiaostudentqaq.github.io/post/jian-zao-zhe-mo-shi-2/">
                  <h2 class="post-title">建造者模式-2</h2>
                </a>
                <div class="post-date">
                  2023-10-26
                </div>
                <div class="post-abstract">
                  
                </div>
              </div>
              
            </article>
          

          <div class="pagination-container">
  
  
    <a href="https://xiaostudentqaq.github.io/page/2" class="next">下一页 <i class="icon-arrow-ios-forward-outline"></i></a>
  
</div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>






  </body>
</html>
